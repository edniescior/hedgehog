package xbi.testutils.dbunit;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;
import org.dbunit.Assertion;
import org.dbunit.DatabaseUnitException;
import org.dbunit.dataset.DataSetException;
import org.dbunit.dataset.IDataSet;
import org.dbunit.dataset.ITable;
import org.dbunit.dataset.SortedTable;
import org.dbunit.dataset.filter.DefaultColumnFilter;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.pentaho.di.core.CheckResultInterface;
import org.pentaho.di.core.encryption.Encr;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import xbi.testutils.kettle.Runner;
import xbi.testutils.kettle.RunnerFactory;

public abstract class KettleTestCase {

	private static final Logger LOGGER = LoggerFactory
			.getLogger(KettleTestCase.class);

	protected Connector connector;
	protected Runner runner;

	/**
	 * @param kettleFile
	 *            A File specifying the Kettle XML file for the Job or
	 *            Transformation to run
	 */
	public KettleTestCase(File kettleFile) {
		runner = RunnerFactory.createRunner(kettleFile);
	}

	@Test
	public void checkResults() {
		assertComplete();
		for (CheckResultInterface remark : runner.getStepRemarks()) {
			assertTrue("Error found in step: " + remark.getText(),
					remark.getType() != CheckResultInterface.TYPE_RESULT_ERROR);
		}
	}

	/**
	 * Test methods should call this to make sure that the Job or Transformation
	 * completed prior to the test method running.
	 */
	public void assertComplete() {
		if (!runner.isComplete()) {
			fail("Transformation did not complete, bailing");
		}
	}

	/**
	 * Constructs the Runner and Connector, verifies and runs the Job or
	 * Transformation
	 */
	@Before
	public void preflight() {
		try {
			runner.setup();

			// Note that the following system properties are set via the
			// kettle.properties file under KETTLE_HOME
			// Hard-coded to use Oracle, but that could be made configurable.
			String url = "jdbc:oracle:thin:@"
					+ System.getProperty("XBIS_DBNAME");
			String username = System.getProperty("XBIS_STG_USER");
			String password = Encr.decryptPasswordOptionallyEncrypted(System
					.getProperty("XBIS_STG_PASSWORD"));
			String schema = System.getProperty("XBIS_STG_SCHEMA");

			connector = new Connector(url, username, password, schema);

			// After Kettle and DBUnit are set up, do special processing
			afterSetup();

			runner.verify();
			runner.run();
		} catch (Exception e) {
			LOGGER.error("Encountered error during preflight: " + e);
		}
	}

	/**
	 * Subclasses should implement this method with calls to
	 * Connector.registerSequenceForReset, Connector.registerTableForCleanup.
	 * Runs before tests so that it's finished before cleanupTestData runs.
	 */
	@Before
	public abstract void registerObjectsForCleanup();

	/**
	 * After the test has run, execute SQL generated by generateCleanupSQL and
	 * delete test files.
	 */
	@After
	public void cleanupTestData() {
		connector.cleanupDatabase();
	}

	/**
	 * Do any post setup actions here like loading test data for a test or
	 * setting properties
	 */
	protected abstract void afterSetup();

	/**
	 * Compare a database table to a DBUnit XML file
	 * 
	 * @param tableName
	 *            schema-qualified table name
	 * @param expected
	 *            XML file
	 */
	protected void compareDataSets(String tableName, File expected) {
		compareDataSets(tableName, expected, null);
	}

	/**
	 * Compare a database table to a DBUnit XML file, with ordering specified
	 * 
	 * @param tableName
	 *            schema-qualified table name
	 * @param expected
	 *            XML file
	 * @param orderByCols
	 *            column names to order by (ascending)
	 */
	protected void compareDataSets(String tableName, File expected,
			String[] orderByCols) {

		try {

			// Load expected data from an XML data set.
			IDataSet expectedDataSet = connector.buildDataSet(expected);
			ITable rawExpectedTable = expectedDataSet.getTable(tableName);

			// Load actual data from database and filter out unwanted columns
			// based in the XML expected data set.
			ITable rawActualTable = connector.getDatabaseDataSet().getTable(
					tableName);
			ITable filteredActualTable = DefaultColumnFilter
					.includedColumnsTable(rawActualTable, rawExpectedTable
							.getTableMetaData().getColumns());

			// Sort data sets by their own columns as defined by the ITable
			// metadata, unless order by explicitly defined.
			// NB. No actual sorting (shuffling indexes) occurs until the data set 
			// is accessed for the first time, i.e. later in the assert.
			SortedTable expectedTable = null;
			SortedTable actualTable = null;
			if (orderByCols == null || orderByCols.length == 0) {
				expectedTable = new SortedTable(rawExpectedTable);
				actualTable = new SortedTable(filteredActualTable);
			} else {
				expectedTable = new SortedTable(rawExpectedTable, orderByCols);
				expectedTable.setUseComparable(true); // must be called right after constructor
				actualTable = new SortedTable(filteredActualTable, orderByCols);
				actualTable.setUseComparable(true);  // must be called right after constructor
			}

			// No sorting 
			Assertion.assertEquals(expectedTable, actualTable);
		} catch (DataSetException e) {
			LOGGER.error(e.getMessage());
			fail(e.toString());
		} catch (DatabaseUnitException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	/**
	 * Compares the two files as simple String objects. Strips quotations and
	 * whitespace prior to comparison.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void compareFiles(File expected, File actual) throws IOException {
		String stopwordRegex = "[\\\"\\s\\\']";
		compareFiles(expected, actual, stopwordRegex);
	}

	/**
	 * Compares the two files as simple String objects. A string regular
	 * expression for stopwords must be supplied.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void compareFiles(File expected, File actual, String stopwordRegex)
			throws IOException {
		String expectedString = FileUtils.readFileToString(expected)
				.replaceAll(stopwordRegex, "");
		String actualString = FileUtils.readFileToString(actual).replaceAll(
				stopwordRegex, "");
		assertEquals(expectedString, actualString);
	}
}
