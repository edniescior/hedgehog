package xbi.testutils.dbunit;

import static org.junit.Assert.assertTrue;
import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.File;
import java.io.IOException;

import org.apache.commons.io.FileUtils;
import org.dbunit.Assertion;
import org.dbunit.dataset.IDataSet;
import org.dbunit.dataset.ITable;
import org.dbunit.dataset.SortedTable;
import org.dbunit.dataset.filter.DefaultColumnFilter;
import org.junit.After;
import org.junit.Before;
import org.junit.Test;
import org.pentaho.di.core.CheckResultInterface;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import xbi.testutils.kettle.Runner;
import xbi.testutils.kettle.RunnerFactory;

public abstract class KettleTestCase {

	private static final Logger LOGGER = LoggerFactory
			.getLogger(KettleTestCase.class);

	protected Connector connector;
	protected Runner runner;

	/**
	 * @param kettleFile
	 *            A File specifying the Kettle XML file for the Job or
	 *            Transformation to run
	 */
	public KettleTestCase(File kettleFile) {
		runner = RunnerFactory.createRunner(kettleFile);
	}

	@Test
	public void checkResults() {
		assertComplete();
		for (CheckResultInterface remark : runner.getStepRemarks()) {
			assertTrue("Error found in step: " + remark.getText(),
					remark.getType() != CheckResultInterface.TYPE_RESULT_ERROR);
		}
	}

	/**
	 * Test methods should call this to make sure that the Job or Transformation
	 * completed prior to the test method running.
	 */
	public void assertComplete() {
		if (!runner.isComplete()) {
			fail("Transformation did not complete, bailing");
		}
	}

	/**
	 * Constructs the Runner and Connector, verifies and runs the Job or
	 * Transformation
	 */
	@Before
	public void preflight() {
		try {
			runner.setup();

			// Note that the following system properties are set via the
			// kettle.properties file under KETTLE_HOME
			// String url = "jdbc:postgresql://" +
			// System.getProperty(getPropertyPrefix() + ".db.host") + "/" +
			// System.getProperty(getPropertyPrefix() + ".db.name");
			// String username = System.getProperty(getPropertyPrefix() +
			// ".db.username");
			// String password =
			// Encr.decryptPasswordOptionallyEncrypted(System.getProperty(getPropertyPrefix()
			// + ".db.password"));

			String url = "jdbc:oracle:thin:@(DESCRIPTION= (ADDRESS_LIST= (LOAD_BALANCE=yes) (ADDRESS= (PROTOCOL=TCP) (HOST=ccpscn-dt-a-dqi.dt.ccp.cable.comcast.com) (PORT=1521) ) ) (CONNECT_DATA= (FAILOVER_MODE= (TYPE=select) (METHOD=basic) (RETRIES=180) (DELAY=5) ) (SERVER=dedicated) (SERVICE_NAME=DXBID_SERV.dt.ccp.cable.comcast.com) ) )";
			String username = "eniescior";
			String password = "k8Zj6l";
			String schema = "eniescior";

			connector = new Connector(url, username, password, schema);

			// After Kettle and DBUnit are set up, do special processing
			afterSetup();

			runner.verify();
			runner.run();
		} catch (Exception e) {
			LOGGER.error("Encountered error during preflight: " + e);
		}
	}

	/**
	 * Subclasses should implement this method with calls to
	 * Connector.registerSequenceForReset, Connector.registerTableForCleanup.
	 * Runs before tests so that it's finished before cleanupTestData runs.
	 */
	@Before
	public abstract void registerObjectsForCleanup();

	/**
	 * After the test has run, execute SQL generated by generateCleanupSQL and
	 * delete test files.
	 */
	@After
	public void cleanupTestData() {
		connector.cleanupDatabase();
	}

	/**
	 * Do any post setup actions here like loading test data for a test or
	 * setting properties
	 */
	protected abstract void afterSetup();

	/**
	 * @return The prefix used to separate properties for different applications
	 *         and databases, e.g., 'analytics'
	 */
	protected abstract String getPropertyPrefix();

	/**
	 * Compare a database table to a DBUnit XML file
	 * 
	 * @param tableName
	 *            schema-qualified table name
	 * @param expected
	 *            XML file
	 */
	protected void compareDataSets(String tableName, File expected) {
		// Fetch database data after executing your code
		try {
			ITable actualTable = connector.getDatabaseDataSet().getTable(
					tableName);

			// Load expected data from an XML dataset
			IDataSet expectedDataSet = connector.buildDataSet(expected);

			ITable expectedTable = new SortedTable(
					expectedDataSet.getTable(tableName));
			ITable filteredTable = DefaultColumnFilter.includedColumnsTable(
					actualTable, expectedTable.getTableMetaData().getColumns());

			// ITable sortedAndFilteredTable = new SortedTable(new
			// RowFilterTable(
			// filteredTable, new UnknownRowFilter()));
			ITable sortedAndFilteredTable = new SortedTable(filteredTable);

			// Assert actual database table match expected table
			Assertion.assertEquals(expectedTable, sortedAndFilteredTable);

		} catch (Exception e) {
			LOGGER.error(e.getMessage());
			fail(e.toString());
		}
	}

	/**
	 * Compares the two files as simple String objects. Strips quotations and
	 * whitespace prior to comparison.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void compareFiles(File expected, File actual) throws IOException {
		String stopwordRegex = "[\\\"\\s\\\']";
		compareFiles(expected, actual, stopwordRegex);
	}

	/**
	 * Compares the two files as simple String objects. A string regular
	 * expression for stopwords must be supplied.
	 * 
	 * @param expected
	 * @param actual
	 */
	protected void compareFiles(File expected, File actual, String stopwordRegex)
			throws IOException {
		String expectedString = FileUtils.readFileToString(expected)
				.replaceAll(stopwordRegex, "");
		String actualString = FileUtils.readFileToString(actual).replaceAll(
				stopwordRegex, "");
		assertEquals(expectedString, actualString);
	}
}
